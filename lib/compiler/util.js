"use strict";

var colors = require('colors/safe');
var version = require('../version');
var util = exports;

exports.log = function(message) {
	console.log(colors.gray("[STREAMLINE] " + message));
}
exports.warn = function(message) {
	console.warn(colors.yellow("[STREAMLINE] " + message));
}
exports.error = function(message) {
	console.error(colors.magenta("[STREAMLINE] " + message));
}

exports.getOptions = function(options) {
	var opts = {
		runtime: "galaxy"
	};
	Object.keys(options = options || {}).forEach(function(opt) {
		if (/^(fast)$/.test(opt)) {
			util.warn("Ignoring obsolete option: " + opt);
			return;
		}
		opts[opt] = options[opt];
	});
	if (opts.fibers) opts.runtime = "fibers";
	delete opts.fibers;
	if (opts.generators) opts.runtime = "galaxy";
	delete opts.generators;
	return opts;
}

exports.babelOptions = function(options, method) {
	options.babel = options.babel || {};
	var babelOpts = {
		// Setting this will remove the currently hooked extensions of .es6, `.es`, `.jsx`
		// and .js so you'll have to add them back if you want them to be used again.
		plugins: ['streamline-plugin'],
		extensions: ["._js"],
		//cache: false,
	};
	if (options.cache != null) babelOpts.cache = options.cache;
	Object.keys(options.babel).forEach(function(opt) {
		if (options.babel[opt] != null) babelOpts[opt] = options.babel[opt];
	});
	if (method !== "register") {
		// babel throw on irrelevant options - delete them
		delete babelOpts.extensions;
		delete babelOpts.cache;
	}
	// see https://github.com/babel/babel/issues/1833
	babelOpts.extra = {
		streamline: {
			runtime: options.runtime,
			verbose: options.verbose,
		},
	};
	return babelOpts;
};

exports.canCompile = function(path) {
	return /\._?(js|coffee)$/.test(path);
};

exports.banner = function(options) {
	var optStr = "";
	if (options.standalone) optStr += " --standalone";
	if (options.aggressive) optStr += " --aggressive";
	return "/*** Generated by streamline " + version + optStr + " - DO NOT EDIT ***/";
};

exports.parseShebang = function(content) {
	if (content[0] === '#' && content[1] === '!') {
		var n = content.indexOf("\n");
		var le = "\n";
		if (n !== -1) {
			var shebang = content.substr(0, n);
			if (shebang[shebang.length - 1] === "\r") {
				le = "\r\n";
				shebang = shebang.substr(0, shebang.length - 1);
			}
			content = content.substr(n + 1);
			return [shebang, content, le];
		}
	}
	return ['', content, ''];
};

exports.deprecate = function(module, message) {
	util.warn("Module " + module.id + " is deprecated: " + message);
	Object.keys(module.exports).forEach(function(name) {
		var fn = module.exports[name];
		if (typeof fn === 'function') {
			module.exports[name] = function() {
				if (!module.exports[name].warned) util.warn("Module " + module.id + ": calling deprecated function: " + name);
				module.exports[name].warned = true;
				return fn.apply(this, arguments);
			};
		}
	})
};